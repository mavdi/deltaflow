<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Deltaflow Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'JetBrainsMono Nerd Font', 'FiraCode Nerd Font', 'Hack Nerd Font', monospace;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="loading">Loading pipelines...</div>
    <canvas id="canvas"></canvas>
    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const loadingEl = document.getElementById('loading');

// Layout constants
const STEP_WIDTH = 120;
const STEP_HEIGHT = 40;
const STEP_GAP = 60;
const PIPELINE_GAP = 80;
const PADDING = 40;

// Color constants
const COLOR_BG = '#000000';
const COLOR_BORDER = '#ffffff';
const COLOR_TEXT = '#ffffff';
const COLOR_LABEL = '#888888';
const COLOR_CONNECTOR = '#666666';
const COLOR_FORK = '#ffffff';

// State
let graph = null;
let pipelinePositions = new Map(); // pipeline name -> {x, y, width}
let offset = { x: 0, y: 0 };
let isDragging = false;
let dragStart = { x: 0, y: 0 };

// Resize canvas to window
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    render();
}
window.addEventListener('resize', resize);

// Pan with mouse drag
canvas.addEventListener('mousedown', e => {
    isDragging = true;
    dragStart = { x: e.clientX - offset.x, y: e.clientY - offset.y };
});
canvas.addEventListener('mousemove', e => {
    if (isDragging) {
        offset.x = e.clientX - dragStart.x;
        offset.y = e.clientY - dragStart.y;
        render();
    }
});
canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mouseleave', () => isDragging = false);

// Layout pipelines
function layout(data) {
    // Topological sort: find roots (no incoming connections)
    const incoming = new Map();
    data.pipelines.forEach(p => incoming.set(p.name, 0));
    data.connections.forEach(c => {
        incoming.set(c.to, (incoming.get(c.to) || 0) + 1);
    });

    // Sort: roots first, then by name
    const sorted = [...data.pipelines].sort((a, b) => {
        const aIn = incoming.get(a.name) || 0;
        const bIn = incoming.get(b.name) || 0;
        if (aIn !== bIn) return aIn - bIn;
        return a.name.localeCompare(b.name);
    });

    // Position pipelines
    let y = PADDING;
    sorted.forEach(pipeline => {
        const width = pipeline.steps.length * (STEP_WIDTH + STEP_GAP) - STEP_GAP;
        pipelinePositions.set(pipeline.name, { x: PADDING, y, width });
        y += STEP_HEIGHT + PIPELINE_GAP;
    });
}

// Render
function render() {
    if (!graph) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offset.x, offset.y);

    // Draw connections first (behind nodes)
    ctx.strokeStyle = COLOR_FORK;
    ctx.lineWidth = 4;
    ctx.setLineDash([]);

    graph.connections.forEach(conn => {
        const from = pipelinePositions.get(conn.from);
        const to = pipelinePositions.get(conn.to);
        if (!from || !to) return;

        const fromX = from.x + from.width;
        const fromY = from.y + STEP_HEIGHT / 2;
        const toX = to.x;
        const toY = to.y + STEP_HEIGHT / 2;

        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        // Curve down/up to target
        const midY = (fromY + toY) / 2;
        ctx.bezierCurveTo(
            fromX + 40, fromY,
            toX - 40, toY,
            toX, toY
        );
        ctx.stroke();

        // Draw connection type label
        const typeName = conn.type || 'fork';
        const labelX = (fromX + toX) / 2;
        const labelY = (fromY + toY) / 2 - 6;

        ctx.fillStyle = COLOR_LABEL;
        ctx.font = '9px "JetBrainsMono Nerd Font", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(typeName, labelX, labelY);
        ctx.textAlign = 'left';
    });

    // Draw pipelines
    graph.pipelines.forEach(pipeline => {
        const pos = pipelinePositions.get(pipeline.name);
        if (!pos) return;

        // Pipeline label
        ctx.fillStyle = COLOR_LABEL;
        ctx.font = '12px "JetBrainsMono Nerd Font", monospace';
        ctx.fillText(pipeline.name, pos.x, pos.y - 8);

        // Steps
        pipeline.steps.forEach((step, i) => {
            const x = pos.x + i * (STEP_WIDTH + STEP_GAP);
            const y = pos.y;

            // Box
            ctx.fillStyle = COLOR_BG;
            ctx.strokeStyle = COLOR_BORDER;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(x, y, STEP_WIDTH, STEP_HEIGHT);
            ctx.fill();
            ctx.stroke();

            // Step name
            ctx.fillStyle = COLOR_TEXT;
            ctx.font = '11px "JetBrainsMono Nerd Font", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                step.name.length > 14 ? step.name.slice(0, 12) + '..' : step.name,
                x + STEP_WIDTH / 2,
                y + STEP_HEIGHT / 2
            );
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';

            // Connector to next step
            if (i < pipeline.steps.length - 1) {
                ctx.strokeStyle = COLOR_CONNECTOR;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(x + STEP_WIDTH, y + STEP_HEIGHT / 2);
                ctx.lineTo(x + STEP_WIDTH + STEP_GAP, y + STEP_HEIGHT / 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Arrow head
                const arrowX = x + STEP_WIDTH + STEP_GAP - 8;
                const arrowY = y + STEP_HEIGHT / 2;
                ctx.fillStyle = COLOR_CONNECTOR;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY - 4);
                ctx.lineTo(arrowX + 8, arrowY);
                ctx.lineTo(arrowX, arrowY + 4);
                ctx.closePath();
                ctx.fill();
            }
        });
    });

    ctx.restore();
}

// Load and render
fetch('/api/graph')
    .then(r => r.json())
    .then(data => {
        loadingEl.style.display = 'none';
        graph = data;
        layout(data);
        resize();
    })
    .catch(err => {
        loadingEl.textContent = 'Error loading graph: ' + err.message;
    });
    </script>
</body>
</html>
