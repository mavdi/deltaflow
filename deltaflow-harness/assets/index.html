<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Deltaflow Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'JetBrainsMono Nerd Font', 'FiraCode Nerd Font', 'Hack Nerd Font', monospace;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
        }
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="loading">Loading pipelines...</div>
    <canvas id="canvas"></canvas>
    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const loadingEl = document.getElementById('loading');

// Layout constants
const STEP_WIDTH = 120;
const STEP_HEIGHT = 40;
const STEP_GAP = 60;
const PIPELINE_GAP = 80;
const PADDING = 40;
const COLUMN_GAP = 250;

// Color constants
const COLOR_BG = '#000000';
const COLOR_BORDER = '#ffffff';
const COLOR_TEXT = '#ffffff';
const COLOR_LABEL = '#888888';
const COLOR_CONNECTOR = '#666666';
const COLOR_FORK = '#ffffff';

// State
let graph = null;
let pipelinePositions = new Map(); // pipeline name -> {x, y, width, column}
let offset = { x: 0, y: 0 };
let isDragging = false;
let dragStart = { x: 0, y: 0 };

// Resize canvas to window
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    render();
}
window.addEventListener('resize', resize);

// Pan with mouse drag
canvas.addEventListener('mousedown', e => {
    isDragging = true;
    dragStart = { x: e.clientX - offset.x, y: e.clientY - offset.y };
});
canvas.addEventListener('mousemove', e => {
    if (isDragging) {
        offset.x = e.clientX - dragStart.x;
        offset.y = e.clientY - dragStart.y;
        render();
    }
});
canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mouseleave', () => isDragging = false);

// Layout pipelines using column-based algorithm
function layout(data) {
    // Build adjacency: who points to whom
    const outgoing = new Map(); // pipeline -> [targets]
    const incoming = new Map(); // pipeline -> [sources]

    data.pipelines.forEach(p => {
        outgoing.set(p.name, []);
        incoming.set(p.name, []);
    });

    data.connections.forEach(c => {
        outgoing.get(c.from)?.push(c.to);
        incoming.get(c.to)?.push(c.from);
    });

    // Detect cycles using DFS, mark back-edges
    // IMPORTANT: Start DFS only from true roots (no incoming edges)
    const visited = new Set();
    const inStack = new Set();
    const backEdges = new Set(); // "from->to" strings

    function detectCycles(node) {
        if (inStack.has(node)) return;
        if (visited.has(node)) return;

        visited.add(node);
        inStack.add(node);

        for (const target of outgoing.get(node) || []) {
            if (inStack.has(target)) {
                backEdges.add(`${node}->${target}`);
            } else {
                detectCycles(target);
            }
        }

        inStack.delete(node);
    }

    // Find true roots (no incoming edges) and start DFS from them
    const trueRoots = data.pipelines.filter(p =>
        (incoming.get(p.name) || []).length === 0
    );
    trueRoots.forEach(p => detectCycles(p.name));

    // If some nodes weren't visited (disconnected or all in cycles), visit them too
    data.pipelines.forEach(p => {
        if (!visited.has(p.name)) detectCycles(p.name);
    });


    // Compute columns: column[p] = max(column[sources] + 1), roots = 0
    const column = new Map();
    const remaining = new Set(data.pipelines.map(p => p.name));

    // Initialize roots (no incoming or only back-edges incoming)
    data.pipelines.forEach(p => {
        const sources = incoming.get(p.name) || [];
        const realSources = sources.filter(s => !backEdges.has(`${s}->${p.name}`));
        if (realSources.length === 0) {
            column.set(p.name, 0);
            remaining.delete(p.name);
        }
    });

    // Iteratively assign columns
    let maxIter = data.pipelines.length * 2;
    while (remaining.size > 0 && maxIter-- > 0) {
        for (const name of remaining) {
            const sources = incoming.get(name) || [];
            const realSources = sources.filter(s => !backEdges.has(`${s}->${name}`));

            // Check if all real sources have columns assigned
            if (realSources.every(s => column.has(s))) {
                const maxSourceCol = Math.max(0, ...realSources.map(s => column.get(s)));
                column.set(name, maxSourceCol + 1);
                remaining.delete(name);
            }
        }
    }

    // Group pipelines by column
    const columns = new Map(); // column index -> [pipeline names]
    for (const [name, col] of column) {
        if (!columns.has(col)) columns.set(col, []);
        columns.get(col).push(name);
    }

    // Position pipelines column by column
    const maxCols = columns.size > 0 ? Math.max(...columns.keys()) + 1 : 0;
    let columnX = PADDING; // Track X position for each column

    for (let col = 0; col < maxCols; col++) {
        const names = columns.get(col) || [];

        // Sort within column (can now use parent Y because col-1 is already positioned)
        if (col === 0) {
            names.sort();
        } else {
            names.sort((a, b) => {
                const aParents = (incoming.get(a) || []).filter(s => !backEdges.has(`${s}->${a}`));
                const bParents = (incoming.get(b) || []).filter(s => !backEdges.has(`${s}->${b}`));
                const aParentY = aParents.length > 0 && pipelinePositions.has(aParents[0])
                    ? pipelinePositions.get(aParents[0]).y : 0;
                const bParentY = bParents.length > 0 && pipelinePositions.has(bParents[0])
                    ? pipelinePositions.get(bParents[0]).y : 0;
                return aParentY - bParentY;
            });
        }

        // Calculate max width in this column
        let maxWidth = 0;
        for (const name of names) {
            const pipeline = data.pipelines.find(p => p.name === name);
            const width = pipeline.steps.length * (STEP_WIDTH + STEP_GAP) - STEP_GAP;
            if (width > maxWidth) maxWidth = width;
        }

        // Position this column
        let y = PADDING;
        for (const name of names) {
            const pipeline = data.pipelines.find(p => p.name === name);
            const width = pipeline.steps.length * (STEP_WIDTH + STEP_GAP) - STEP_GAP;
            pipelinePositions.set(name, { x: columnX, y, width, column: col });
            y += STEP_HEIGHT + PIPELINE_GAP;
        }

        // Move X to next column (max width + gap for arrows)
        columnX += maxWidth + COLUMN_GAP;
    }
}

// Render
function render() {
    if (!graph) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offset.x, offset.y);

    // Draw connections
    graph.connections.forEach(conn => {
        const from = pipelinePositions.get(conn.from);
        const to = pipelinePositions.get(conn.to);
        if (!from || !to) return;

        const fromX = from.x + from.width;
        const fromY = from.y + STEP_HEIGHT / 2;
        const toX = to.x;
        const toY = to.y + STEP_HEIGHT / 2;

        const isBackward = to.column <= from.column;

        // Branch point (diamond) at source
        const branchX = fromX + 20;
        const branchY = fromY;

        // Line from last step to branch point
        ctx.strokeStyle = COLOR_FORK;
        ctx.lineWidth = 4;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(branchX, branchY);
        ctx.stroke();

        // Diamond at branch point
        ctx.fillStyle = COLOR_FORK;
        ctx.beginPath();
        ctx.moveTo(branchX, branchY - 8);
        ctx.lineTo(branchX + 8, branchY);
        ctx.lineTo(branchX, branchY + 8);
        ctx.lineTo(branchX - 8, branchY);
        ctx.closePath();
        ctx.fill();

        // Connection line to target
        ctx.strokeStyle = COLOR_FORK;
        ctx.lineWidth = 4;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(branchX + 8, branchY);

        if (isBackward) {
            // Backward arrow: route above all pipelines, enter target from top
            const midY = 15; // Just above pipeline labels (PADDING is 40)
            const targetCenterX = toX + STEP_WIDTH / 2; // Center of first step
            ctx.lineTo(branchX + 30, branchY);
            ctx.lineTo(branchX + 30, midY);
            ctx.lineTo(targetCenterX, midY);
            ctx.lineTo(targetCenterX, toY - 15); // Stop above the step
            ctx.stroke();

            // Arrow head pointing down into the step
            ctx.beginPath();
            ctx.moveTo(targetCenterX - 6, toY - 20);
            ctx.lineTo(targetCenterX, toY - 8);
            ctx.lineTo(targetCenterX + 6, toY - 20);
            ctx.closePath();
            ctx.fill();
        } else {
            // Forward arrow: S-curve
            const midX = (branchX + toX) / 2;
            ctx.bezierCurveTo(
                branchX + 40, branchY,
                midX, toY,
                toX - 10, toY
            );
        }
        ctx.stroke();

        // Arrow head at target (only for forward arrows - backward arrows draw their own)
        if (!isBackward) {
            ctx.fillStyle = COLOR_FORK;
            ctx.beginPath();
            ctx.moveTo(toX - 18, toY - 6);
            ctx.lineTo(toX - 6, toY);
            ctx.lineTo(toX - 18, toY + 6);
            ctx.closePath();
            ctx.fill();
        }

        // Connection type label
        const typeName = conn.type === 'fork' ? 'fork'
            : conn.type === 'fan_out' ? 'fan_out'
            : 'spawn';
        const labelX = (branchX + toX) / 2;
        const labelY = isBackward
            ? Math.min(fromY, toY) - 50
            : (branchY + toY) / 2 - 10;
        ctx.fillStyle = COLOR_LABEL;
        ctx.font = '9px "JetBrainsMono Nerd Font", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(typeName, labelX, labelY);

        // Condition label if present
        if (conn.condition) {
            ctx.fillText(conn.condition, labelX, labelY + 12);
        }
        ctx.textAlign = 'left';
    });

    // Draw pipelines
    graph.pipelines.forEach(pipeline => {
        const pos = pipelinePositions.get(pipeline.name);
        if (!pos) return;

        // Pipeline label
        ctx.fillStyle = COLOR_LABEL;
        ctx.font = '12px "JetBrainsMono Nerd Font", monospace';
        ctx.fillText(pipeline.name, pos.x, pos.y - 8);

        // Steps
        pipeline.steps.forEach((step, i) => {
            const x = pos.x + i * (STEP_WIDTH + STEP_GAP);
            const y = pos.y;

            // Box
            ctx.fillStyle = COLOR_BG;
            ctx.strokeStyle = COLOR_BORDER;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(x, y, STEP_WIDTH, STEP_HEIGHT);
            ctx.fill();
            ctx.stroke();

            // Step name
            ctx.fillStyle = COLOR_TEXT;
            ctx.font = '11px "JetBrainsMono Nerd Font", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                step.name.length > 14 ? step.name.slice(0, 12) + '..' : step.name,
                x + STEP_WIDTH / 2,
                y + STEP_HEIGHT / 2
            );
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';

            // Connector to next step
            if (i < pipeline.steps.length - 1) {
                ctx.strokeStyle = COLOR_CONNECTOR;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(x + STEP_WIDTH, y + STEP_HEIGHT / 2);
                ctx.lineTo(x + STEP_WIDTH + STEP_GAP, y + STEP_HEIGHT / 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Arrow head
                const arrowX = x + STEP_WIDTH + STEP_GAP - 8;
                const arrowY = y + STEP_HEIGHT / 2;
                ctx.fillStyle = COLOR_CONNECTOR;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY - 4);
                ctx.lineTo(arrowX + 8, arrowY);
                ctx.lineTo(arrowX, arrowY + 4);
                ctx.closePath();
                ctx.fill();
            }
        });
    });

    ctx.restore();
}

// Load and render
fetch('/api/graph')
    .then(r => r.json())
    .then(data => {
        loadingEl.style.display = 'none';
        graph = data;
        layout(data);
        resize();
    })
    .catch(err => {
        loadingEl.textContent = 'Error loading graph: ' + err.message;
    });
    </script>
</body>
</html>
